// NovaLang Lambda Enhanced Demo
// Testing current Lambda functionality with magic strings and pipeline

print("=== NovaLang Lambda Enhanced Demo ===\n");

// Define a sample collection
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
print("Original numbers:", numbers);

print("\n=== Testing Magic String Operations ===");

// Test filter with magic strings (working)
let evenNumbers = Lambda.filter(numbers, "even");
print("Even numbers:", evenNumbers);

let oddNumbers = Lambda.filter(numbers, "odd");
print("Odd numbers:", oddNumbers);

let positiveNumbers = Lambda.filter(numbers, "positive");
print("Positive numbers:", positiveNumbers);

// Test map with magic strings (working)
let doubledNumbers = Lambda.map(numbers, "double");
print("Doubled numbers:", doubledNumbers);

let squaredNumbers = Lambda.map(numbers, "square");
print("Squared numbers:", squaredNumbers);

print("\n=== Testing Pipeline Operations ===");

// Test pipeline with method chaining
let pipeline = Lambda.pipeline(numbers);
let result1 = pipeline
    .filter("even")
    .map("square")
    .sort("desc")
    .take(3)
    .execute();

print("Pipeline result (even → square → desc sort → take 3):", result1);

// Test chain operations
let chain = Lambda.chain([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
let result2 = chain
    .filter("odd")
    .map("double")
    .sort("asc")
    .skip(2)
    .execute();

print("Chain result (odd → double → asc sort → skip 2):", result2);

print("\n=== Testing Statistical Operations ===");

// Test statistical functions
print("Count:", Lambda.count(numbers));
print("Sum:", Lambda.sum(numbers));
print("Average:", Lambda.average(numbers));
print("Min:", Lambda.min(numbers));
print("Max:", Lambda.max(numbers));
print("First:", Lambda.first(numbers));
print("Last:", Lambda.last(numbers));

// Test distinct and reverse
let duplicates = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4];
print("\nDuplicates:", duplicates);
print("Distinct:", Lambda.distinct(duplicates));
print("Reversed:", Lambda.reverse(duplicates));

print("\n=== Testing Complex Pipelines ===");

// Complex pipeline combining multiple operations
let complexResult = Lambda.pipeline(numbers)
    .filter("even")
    .map("square")
    .filter("positive")
    .sort("desc")
    .take(5)
    .execute();

print("Complex pipeline result:", complexResult);

// Another complex chain
let chainResult = Lambda.chain([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
    .filter("even")
    .map("double")
    .sort("asc")
    .skip(3)
    .take(4)
    .execute();

print("Complex chain result:", chainResult);

print("\n=== Testing Collection Types ===");

// Test with different collection types
let arrayList = ArrayList.create();
ArrayList.add(arrayList, 1);
ArrayList.add(arrayList, 2);
ArrayList.add(arrayList, 3);
ArrayList.add(arrayList, 4);
ArrayList.add(arrayList, 5);

print("ArrayList:", arrayList);
let filteredArrayList = Lambda.filter(arrayList, "even");
print("Filtered ArrayList:", filteredArrayList);

print("\n=== Performance Test ===");

// Generate larger dataset for performance testing
let largeNumbers = [];
for (let i = 1; i <= 100; i++) {
    largeNumbers[i-1] = i;
}

print("Processing", Lambda.count(largeNumbers), "numbers...");

let performanceResult = Lambda.pipeline(largeNumbers)
    .filter("even")
    .map("square")
    .filter("positive")
    .sort("desc")
    .take(10)
    .execute();

print("Top 10 squared even numbers:", performanceResult);

print("\n=== Status Summary ===");
print("✅ Magic string operations working perfectly");
print("✅ Pipeline pattern with method chaining functional");
print("✅ Statistical operations working");
print("✅ Collection type support confirmed");
print("⚠️  Function parameters need interpreter integration");
print("✅ Backward compatibility maintained");

print("\n=== Demo Complete! ===");
