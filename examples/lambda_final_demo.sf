// NovaLang Lambda Enhanced Demo
// Testing current Lambda functionality with magic strings and pipeline

print("=== NovaLang Lambda Enhanced Demo ===\n");

// Define a sample collection
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
print("Original numbers:", numbers);

print("\n=== Testing Magic String Operations ===");

// Test filter with magic strings (working)
let evenNumbers = Lambda.filter(numbers, "even");
print("Even numbers:", evenNumbers);

let oddNumbers = Lambda.filter(numbers, "odd");
print("Odd numbers:", oddNumbers);

let positiveNumbers = Lambda.filter(numbers, "positive");
print("Positive numbers:", positiveNumbers);

// Test map with magic strings (working)
let doubledNumbers = Lambda.map(numbers, "double");
print("Doubled numbers:", doubledNumbers);

let squaredNumbers = Lambda.map(numbers, "square");
print("Squared numbers:", squaredNumbers);

print("\n=== Testing Statistical Operations ===");

// Test statistical functions
print("Count:", Lambda.count(numbers));
print("Sum:", Lambda.sum(numbers));
print("Average:", Lambda.average(numbers));
print("Min:", Lambda.min(numbers));
print("Max:", Lambda.max(numbers));
print("First:", Lambda.first(numbers));
print("Last:", Lambda.last(numbers));

// Test distinct and reverse
let duplicates = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4];
print("\nDuplicates:", duplicates);
print("Distinct:", Lambda.distinct(duplicates));
print("Reversed:", Lambda.reverse(duplicates));

print("\n=== Testing Pipeline Pattern ===");

// Test pipeline using the correct syntax with arrays
let pipelineResult1 = Lambda.pipeline(numbers, ["filter", "even"], ["map", "square"], ["sort", "desc"], ["take", "3"]);
print("Pipeline result (even → square → desc sort → take 3):", pipelineResult1);

let pipelineResult2 = Lambda.pipeline(numbers, ["filter", "odd"], ["map", "double"], ["sort", "asc"], ["skip", "2"]);
print("Pipeline result (odd → double → asc sort → skip 2):", pipelineResult2);

print("\n=== Testing Chain Operations ===");

// Test chain operations
let chainResult1 = Lambda.chain(numbers, ["filter", "even"], ["map", "square"], ["sort", "desc"], ["take", "5"]);
print("Chain result (even → square → desc sort → take 5):", chainResult1);

let chainResult2 = Lambda.chain(numbers, ["filter", "positive"], ["map", "double"], ["sort", "asc"], ["skip", "3"], ["take", "4"]);
print("Chain result (positive → double → asc sort → skip 3 → take 4):", chainResult2);

print("\n=== Testing Complex Operations ===");

// More complex pipeline operations
let complexResult = Lambda.pipeline(numbers, ["filter", "even"], ["map", "square"], ["distinct"], ["sort", "desc"], ["take", "3"]);
print("Complex pipeline result:", complexResult);

// Test with larger numbers
let bigNumbers = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
let bigResult = Lambda.chain(bigNumbers, ["filter", "even"], ["map", "half"], ["sort", "asc"], ["take", "5"]);
print("Big numbers chain result:", bigResult);

print("\n=== Testing Sort Variations ===");

let unsorted = [5, 2, 8, 1, 9, 3];
print("Unsorted:", unsorted);
print("Sorted ascending:", Lambda.sort(unsorted, "asc"));
print("Sorted descending:", Lambda.sort(unsorted, "desc"));

print("\n=== Testing Take and Skip ===");

print("Take first 3:", Lambda.take(numbers, 3));
print("Take first 5:", Lambda.take(numbers, 5));
print("Skip first 3:", Lambda.skip(numbers, 3));
print("Skip first 7:", Lambda.skip(numbers, 7));

print("\n=== Testing Advanced Pipelines ===");

// Test pipeline with no parameters operations
let advancedResult1 = Lambda.pipeline(duplicates, ["distinct"], ["sort", "asc"], ["reverse"]);
print("Advanced pipeline (distinct → sort asc → reverse):", advancedResult1);

// Test pipeline with mixed operations
let mixedNumbers = [5, -3, 8, -1, 12, 0, -7, 15, 3, -2];
let advancedResult2 = Lambda.pipeline(mixedNumbers, ["filter", "positive"], ["map", "square"], ["sort", "desc"], ["take", "5"]);
print("Mixed numbers pipeline (positive → square → desc sort → take 5):", advancedResult2);

print("\n=== Testing Performance ===");

// Generate larger dataset for performance testing
let largeNumbers = [];
for (let i = 1; i <= 50; i++) {
    largeNumbers[i-1] = i;
}

print("Processing", Lambda.count(largeNumbers), "numbers...");

let performanceResult = Lambda.pipeline(largeNumbers, ["filter", "even"], ["map", "square"], ["sort", "desc"], ["take", "10"]);
print("Top 10 squared even numbers:", performanceResult);

print("\n=== Status Summary ===");
print("✅ Magic string operations working perfectly");
print("✅ Lambda.filter and Lambda.map with predefined operations");
print("✅ Pipeline pattern with operation arrays");
print("✅ Chain operations with multiple transformations");
print("✅ Statistical operations (count, sum, average, min, max)");
print("✅ Collection operations (first, last, distinct, reverse)");
print("✅ Sorting operations (asc, desc)");
print("✅ Take and Skip operations");
print("✅ Complex multi-step data processing");
print("⚠️  User-defined function parameters need interpreter integration");
print("✅ Backward compatibility maintained");

print("\n=== Demo Complete! ===");
